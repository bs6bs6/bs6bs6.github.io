[{"categories":["leetcode"],"content":" public void q_sort(int l,int r, int[] nums){ if (l \u003e= r) return; int i = l - 1; int j = r + 1; int x = nums[l + r \u003e\u003e 1]; while (i \u003c j){ do i ++ ; while (nums[i] \u003c x); do j -- ; while (nums[j] \u003e x); if (i \u003c j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } q_sort(l, j,nums); q_sort(j + 1, r,nums); } ","date":"2023-11-16","objectID":"/grace_q_sort_code/:0:1","tags":["leetcode"],"title":"Grace q_sort Code","uri":"/grace_q_sort_code/"},{"categories":["Design Patterns"],"content":"Why can’t we build a Singleton Interface in Java？ This is a typical Singleton implementation in Java program: public class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } That’s a graceful Singleton implementation in C#: public abstract class Singleton \u003cT\u003e{ private static T singleton; } In this C# code, we can simply extend this abstract Singleton class to make the Class a Singleton class. But we can never do this in Java. That’s because We cannot define a static Generics type(Class) in Java. Why does this thing happen? Why it works in C#? To figure out this question, we should focus on differences in implementation of Generics between Java and C#. Generics in Java: Type Erasure In Java, generics were introduced to provide type safety at compile-time. However, at runtime, generic information is erased, i.e., it disappears. This means that at the bytecode level, generics don’t exist, and everything degenerates to its upper bound, typically the Object type. Why choose type erasure? Mainly to maintain backward compatibility with older versions of Java code. A consequence of this approach is that at runtime, you cannot inquire whether an object is of a specific generic type (for example, you cannot determine whether a collection is a List or a List). Generics in C#: Reification In C#, generics retain their type information at runtime. That is, when you create a List, the CLR (Common Language Runtime) generates a specific type for it, different from the type of List. This allows C# to perform type queries, conversions, and other operations dependent on generic type information at runtime. Of course, this approach has a downside: since each different generic instance might require separate code, it can potentially increase the size and memory usage of the application. Both methods have their advantages and disadvantages. Java chose type erasure for backward compatibility, while C#, without such historical baggage, opted to retain runtime generic information. This difference results in varying behavior between Java and C# when using generics. ","date":"2023-10-12","objectID":"/why_cant_we_build_a_singleton_interface_in_java/:0:1","tags":["Java","Design Patterns"],"title":"Why can't we build a Singleton Interface in Java？","uri":"/why_cant_we_build_a_singleton_interface_in_java/"},{"categories":["Wsl"],"content":"SSH to WSL 同一个局域网下实现Mac ssh连接WSL。 Task.ps1作为定时任务，windows内设置开机执行 # 获取管理员权限 If (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]\"Administrator\")) { $arguments = \"\u0026 '\" + $myinvocation.mycommand.definition + \"'\" Start-Process powershell -Verb runAs -ArgumentList $arguments Break } $wsl2Name = \"Ubuntu-22.04\" # 设置WSL2镜像的名字 $wsl2PORT = 2222 # 设置WSL2中sshd中的端口 $listenPORT = 2222 # 设置windows监听的端口，访问windows该端口将转发给WSL2中的上面那个端口 # 获取WSL2的eth0的IP地址 wsl -d $wsl2Name sudo service ssh --full-restart $wsl2inet = wsl -d $wsl2Name ifconfig | Select-String -Pattern \"inet.*?(?\u003cip\u003e[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}).*?net\" $wsl2ip = $wsl2inet.Matches[0].Groups.Item(\"ip\").Value # 设置windows到WSL2的端口转发 netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=$listenPORT connectaddress=$wsl2ip connectport=$wsl2PORT # 打开防火墙，放行外部访问本机的流量 netsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=$listenPORT ","date":"2023-08-21","objectID":"/ssh2wsl/:0:1","tags":["wsl","ssh"],"title":"MacOS通过SSH连接Wsl","uri":"/ssh2wsl/"},{"categories":["test"],"content":"Hello World! ","date":"2023-07-16","objectID":"/hello/:0:1","tags":["Hello"],"title":"Hello","uri":"/hello/"}]