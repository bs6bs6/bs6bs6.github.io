# 

## Why Redis is so fast with Single-Threaded processes？
---
title: "Why is Redis so fast with Single-threaded processes?"
date: 2023-11-16T18:18:55+08:00
draft: false
tags: ["Redis"]
categories: ["Redis"]
---

### Is Redis single-threaded

Redis 单线程指的是*接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端*这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。
但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程(Blocking IO)的：

Redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；
Redis 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。
之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

### Redis的单线程为什么这么快呢？

之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：

1. Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
2. Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
3. Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果

### Redis 6.0 之后为什么引入了多线程？

虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。

所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。

Redis 官方表示，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。

Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。

### 多线程一定更快吗?

答案是No!
原因在于一个CPU就像一条流水线，会执行一系列指令，当很多指令拆成4份（4线程）的时候，它是正好最合适的，少的时候，有一个闲着；而多了，就会存在抢占的情况。举个简单的例子，假设有4个水管可以出水，你现在去接水，那么你在每个水管下放一个桶去接水，自然要比只在一个水管下去接水要快的，但是如果你的水桶数量多于水管数，为了每个水桶都要有水，你在这个过程中就需要去切换水桶，每个水桶换一下，才能都接得上，而换的这个过程就像线程的上下文切换带来的开销。

因此，并不是线程越多越快，最合适的才最快。

### 单线程有时候反而更快

为什么单线程有时候反而会更快呢？还是拿接水为例，假设虽然有4个水管，但是你只有一个桶，因此你一个人从这个水管里一直接水是最快的，而如果你拿两个桶，这个接一点，又换一下，那个接一点，又换一下，中间显然有中断，相同时间内单个桶接的比较多；这就是单核CPU妄图使用多线程提高效率或者每个线程都需要竞争同一把锁而实际可能会导致更慢的缘故。

### 总结

线程上下文切换是有开销的，如果它的收益不能超过它的开销，那么使用多线程来提高效率将得不偿失。因此不要盲目推崇多线程。如果为了提高效率采用多线程，那么线程中最多应为逻辑CPU数。也就是说如果你的程序绑在一个核上或者你只有一个CPU一个核，那么采用多线程只能提高同时处理的能力，而不能提高处理效率。

CPU数量小于进程数量时，所能分配的CPU资源是一定的，再多线程只不过是轮流抢占CPU而已，并不会真正提高处理速度。这意味着，多线程的作用主要在于提高了并发数量，比如http请求，如果是单线程，一次只能接收一个请求，多线程则可以同时接收多个请求。

但是多线程由于轮换使用CPU，会造成单个线程的执行速度变慢（以前CPU供一个线程使用，现在要供多个线程轮流使用了）。但是在多CPU的服务器上，小于CPU数量的多线程就很有优势了，它不但能提高并发数量，而且能提高处理速度。因为在多CPU的服务器上，CPU调度很灵活，当一个线程占用着一个CPU的时候，其他线程可以被分配给其他CPU去处理，从而实现了“真正意义上地并行”。

https://xiaolincoding.com/redis,
https://www.yanbinghu.com/2019/12/25/46016.html
http://blog.zollty.com/b/archive/can-multi-thread-speed-up-the-processing-speed.html

